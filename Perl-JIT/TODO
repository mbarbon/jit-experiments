* Find a better way to handle many types of OPs: clearly
  a giant switch isn't pretty.
* Along the same lines, "foo${a}bar$b" currently generates a giant
  concat OP tree. If not for overloading and friends, this could be
  converted to a join-like operation.
...
* Fix B::Replace
  - handle multiple predecessors (logical ops, ternary)
  - error handling (fail cleanly)
  - test!
* Context
* LVALUE context for assignments
* JIT assignments
  - scalar
  - "simple" list assignment
  - list assignments with OPf_COMMON: ($x, $y) = ($y, $x)
  - analyze control flow and avoid always assigning to the Perl scalar
    (see also doc/codegen.txt)
* Port to LLVM instead of libjit?
* Support everything the old JIT does
* Fix Emit code
* Check support for logical/ternary ops
* Support more type than just doubles in code generator
* Fix all TODOs in Emit.pm
* Think about integrating guards at runtime
* Extract information from subs
  - number of argument
  - inline call for "simple" subs
    - but think about caller
* Globals (for $_)
* Ownership for C++ objects (Type instances created from Perl need to be
  cleaned up (unless assigned to an AST node))
* Overloading to Type instances and LibJIT types; ${$t1} == ${$t2}
  is disgusting
* in Emit.pm, "unspecified" currently means "a plain scalar", which feels wrong
  and there is no "I don't care" value that can be used for requested type

AST related:
* What shall we do about "integer" variants of operations like "i_multiply"?
  => I think: Emit regular multiplication AST OP with an annotation indicating
     that it forces integer input.
