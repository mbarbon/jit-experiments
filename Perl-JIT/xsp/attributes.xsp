%module{Perl::JIT};

%package{Perl::JIT::Types};

#include "types.h"
#include "pj_optree.h"
#include "pj_debug.h"

// in case you wondered, the on-the-fly op modification is not performed
// in a thread safe way; a more robust solution would be to implement
// this in a lexically-scoped peephole optimizer; works for now

%{
void
replace_attributes_import(const char *package, SV *scalar, ...)
  PPCODE:
    PJ_DEBUG("In replace_attributes_import\n");
    bool can_remove = false;
    PerlJIT::AST::Type *type = 0;
    OP *variable = 0;
    LISTOP *entersub = cLISTOPx(PL_op);

    if (pj_parse_attributes(aTHX_ entersub, can_remove, type, variable)) {
      // note that the mangling is done in such a way that pj_parse_attributes
      // can still recognize the optree later
      if (can_remove) {
        PJ_DEBUG("Patching optree to remove attributes::import call\n");
        cUNOPx(entersub)->op_first->op_next = entersub->op_next;
        cUNOPx(entersub)->op_first->op_ppaddr = PL_ppaddr[OP_NULL];
      }

      // at some point we're going to use type information attached
      // to globals, but for now just throw it away
      delete type;
    }

    if (!can_remove) {
      PJ_DEBUG("Calling original attributes::import\n");
      SV *attributes_import = SvRV(get_sv("Perl::JIT::Types::OLD_IMPORT", 0));

      // remove attributes we understood
      SP = &ST(1);
      for (int i = 2; i < items; ++i) {
        if (!PerlJIT::AST::is_type(SvPV_nolen(ST(i))))
          PUSHs(ST(i));
      }

      PUSHMARK(MARK);
      PUTBACK;

      call_sv(attributes_import, GIMME_V);
    }

    // there is yet another brokenness for attributes in 5.14 (likely other
    // versions, not tested):
    // perl -E 'sub MODIFY_SCALAR_ATTRIBUTES{}; sub inc { my ($x, $y) : Foo = @_; return $x + $y }; say inc(1,2)'
    // fails because Perl emits an extra OP_PUSHMARK before the attribute
    // method calls
    // TODO also check with direct calls to attributes->import
  #if PERL_VERSION < 18 // TODO need to check when exactly this was fixed
    // this pops the extra mark, if there is one
    if ((entersub->op_flags & OPf_SPECIAL) && TOPMARK == MARK - PL_stack_base)
       POPMARK;

    // and this goes hunting for the extra OP_PUSHMARK and nulls it
    // TODO might be broken for SASSIGN as well
    if ((entersub->op_flags & OPf_SPECIAL) && !entersub->op_sibling
        && entersub->op_next->op_type == OP_AASSIGN) {
      BINOP *assign = cBINOPx(entersub->op_next);
      LISTOP *list = cLISTOPx(assign->op_last);

      // look for a nulled OP_LIST as the last kid
      if (list->op_type == OP_NULL && list->op_targ == OP_LIST
          && list->op_flags & OPf_KIDS
          && list->op_first->op_type == OP_PUSHMARK) {
        // now look for the second OP_PUSMARK, followed by an OP_ENTERSUB
        // with OPf_SPECIAL
        // TODO also check that the last sibling is the current op
        for (OP *pred = list->op_first, *curr = pred->op_sibling;
             curr->op_sibling;
             pred = curr, curr = curr->op_sibling) {
          if (curr->op_type == OP_PUSHMARK
              && curr->op_sibling->op_type == OP_ENTERSUB
              && curr->op_sibling->op_flags & OPf_SPECIAL) {
            curr->op_ppaddr = PL_ppaddr[OP_NULL];
          }
        }
      }
    }
  #endif

%}
